(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{605:function(v,a,_){"use strict";_.r(a);var t=_(17),e=Object(t.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"day-11"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#day-11"}},[v._v("#")]),v._v(" day_11")]),v._v(" "),_("ol",[_("li",[v._v("在主界面里点击windows   然后点preferences 搜索keys  可以改快捷键")])]),v._v(" "),_("h2",{attrs:{id:"继承性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承性"}},[v._v("#")]),v._v(" 继承性")]),v._v(" "),_("p",[v._v("一、继承性的好处：")]),v._v(" "),_("ol",[_("li",[v._v("减少了代码的冗余，提高了代码的复用性")]),v._v(" "),_("li",[v._v("便于功能的扩展")]),v._v(" "),_("li",[v._v("为之后多态性的使用，提供了前提")])]),v._v(" "),_("p",[v._v("二、继承性的格式：")]),v._v(" "),_("p",[_("code",[v._v("class A extends B{}")])]),v._v(" "),_("blockquote",[_("p",[v._v("A:子类、派生类、subclass")]),v._v(" "),_("p",[v._v("B:父类、超类、基类、superclass")])]),v._v(" "),_("ol",[_("li",[v._v("体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。")]),v._v(" "),_("li",[v._v("子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。")])]),v._v(" "),_("blockquote",[_("p",[v._v("extends：延展、扩展")])]),v._v(" "),_("p",[v._v("三、Java中关于继承性的规定：")]),v._v(" "),_("p",[v._v("1.一个类可以被多个子类继承。")]),v._v(" "),_("p",[v._v("2.Java中类的单继承性：一个类只能有一个父类")]),v._v(" "),_("p",[v._v("3.子父类是相对的概念。")]),v._v(" "),_("p",[v._v("4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类")]),v._v(" "),_("p",[v._v("5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法")]),v._v(" "),_("p",[v._v("四、 1. 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类")]),v._v(" "),_("p",[v._v("所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类")]),v._v(" "),_("p",[v._v("意味着，所有的java类具有java.lang.Object类声明的功能。")])])}),[],!1,null,null,null);a.default=e.exports}}]);